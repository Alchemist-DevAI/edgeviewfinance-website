{"version":3,"file":"middleware.js","sources":["../../../src/server/middleware.ts"],"sourcesContent":["/* eslint-disable max-lines */\nimport type { Span, SpanAttributes } from '@sentry/core';\nimport {\n  addNonEnumerableProperty,\n  flushIfServerless,\n  getIsolationScope,\n  getRootSpan,\n  objectify,\n  SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD,\n  spanToJSON,\n  stripUrlQueryAndFragment,\n  winterCGRequestToRequestData,\n} from '@sentry/core';\nimport {\n  captureException,\n  continueTrace,\n  getActiveSpan,\n  getClient,\n  getCurrentScope,\n  getTraceMetaTags,\n  httpHeadersToSpanAttributes,\n  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,\n  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,\n  setHttpStatus,\n  startSpan,\n  winterCGHeadersToDict,\n  withIsolationScope,\n} from '@sentry/node';\nimport type { APIContext, MiddlewareResponseHandler, RoutePart } from 'astro';\n\ntype MiddlewareOptions = {\n  /**\n   * If true, the client IP will be attached to the event by calling `setUser`.\n   *\n   * Important: Only enable this option if your Astro app is configured for (hybrid) SSR\n   * via the `output: 'server' | 'hybrid'` option in your `astro.config.mjs` file.\n   * Otherwise, Astro will throw an error when starting the server.\n   *\n   * Only set this to `true` if you're fine with collecting potentially personally identifiable information (PII).\n   *\n   * @default false (recommended)\n   */\n  trackClientIp?: boolean;\n};\n\nfunction sendErrorToSentry(e: unknown): unknown {\n  // In case we have a primitive, wrap it in the equivalent wrapper class (string -> String, etc.) so that we can\n  // store a seen flag on it.\n  const objectifiedErr = objectify(e);\n\n  captureException(objectifiedErr, {\n    mechanism: {\n      type: 'astro',\n      handled: false,\n      data: {\n        function: 'astroMiddleware',\n      },\n    },\n  });\n\n  return objectifiedErr;\n}\n\ntype AstroLocalsWithSentry = Record<string, unknown> & {\n  __sentry_wrapped__?: boolean;\n};\n\nexport const handleRequest: (options?: MiddlewareOptions) => MiddlewareResponseHandler = options => {\n  const handlerOptions = {\n    trackClientIp: false,\n    ...options,\n  };\n\n  return async (ctx, next) => {\n    // If no Sentry client exists, just bail\n    // Apart from the case when no Sentry.init() is called at all, this also happens\n    // if a prerendered page is hit first before a ssr page is called\n    // For regular prerendered pages, this is fine as we do not want to instrument them at runtime anyhow\n    // BUT for server-islands requests on a static page, this can be problematic...\n    // TODO: Today, this leads to inconsistent behavior: If a prerendered page is hit first (before _any_ ssr page is called),\n    // Sentry.init() has not been called yet (as this is only injected in SSR pages), so server-island requests are not instrumented\n    // If any SSR route is hit before, the client will already be set up and everything will work as expected :O\n    // To reproduce this: Run the astro-5 \"tracing.serverIslands.test\" only\n    if (!getClient()) {\n      return next();\n    }\n\n    const isDynamicPageRequest = checkIsDynamicPageRequest(ctx);\n\n    // For static (prerendered) routes, we only want to inject the parametrized route meta tags\n    if (!isDynamicPageRequest) {\n      return handleStaticRoute(ctx, next);\n    }\n\n    const activeSpan = getActiveSpan();\n    const rootSpan = activeSpan ? getRootSpan(activeSpan) : undefined;\n\n    // if there is an active span, we just want to enhance it with routing data etc.\n    if (rootSpan && spanToJSON(rootSpan).op === 'http.server') {\n      return enhanceHttpServerSpan(ctx, next, rootSpan);\n    }\n\n    return instrumentRequestStartHttpServerSpan(ctx, next, handlerOptions);\n  };\n};\n\nasync function handleStaticRoute(\n  ctx: Parameters<MiddlewareResponseHandler>[0],\n  next: Parameters<MiddlewareResponseHandler>[1],\n): Promise<Response> {\n  const parametrizedRoute = getParametrizedRoute(ctx);\n  try {\n    const originalResponse = await next();\n\n    // We never want to continue a trace here, so we do not inject trace data\n    // But we do want to inject the parametrized route, as this is used for client-side route parametrization\n    const metaTagsStr = getMetaTagsStr({ injectTraceData: false, parametrizedRoute });\n    return injectMetaTagsInResponse(originalResponse, metaTagsStr);\n  } catch (e) {\n    sendErrorToSentry(e);\n    throw e;\n  }\n}\n\nasync function enhanceHttpServerSpan(\n  ctx: Parameters<MiddlewareResponseHandler>[0],\n  next: Parameters<MiddlewareResponseHandler>[1],\n  rootSpan: Span,\n): Promise<Response> {\n  // Make sure we don't accidentally double wrap (e.g. user added middleware and integration auto added it)\n  const locals = ctx.locals as AstroLocalsWithSentry | undefined;\n  if (locals?.__sentry_wrapped__) {\n    return next();\n  }\n  if (locals) {\n    addNonEnumerableProperty(locals, '__sentry_wrapped__', true);\n  }\n\n  const request = ctx.request;\n  const isolationScope = getIsolationScope();\n  const method = request.method;\n\n  try {\n    const parametrizedRoute = getParametrizedRoute(ctx);\n\n    rootSpan.setAttributes({\n      // This is here for backwards compatibility, we used to set this here before\n      method,\n      [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.astro',\n    });\n\n    if (parametrizedRoute) {\n      rootSpan.setAttributes({\n        [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',\n        'http.route': parametrizedRoute,\n      });\n\n      isolationScope.setTransactionName(`${method} ${parametrizedRoute}`);\n    }\n\n    try {\n      const originalResponse = await next();\n      const metaTagsStr = getMetaTagsStr({ injectTraceData: true, parametrizedRoute });\n      return injectMetaTagsInResponse(originalResponse, metaTagsStr);\n    } catch (e) {\n      sendErrorToSentry(e);\n      throw e;\n    }\n  } finally {\n    await flushIfServerless();\n  }\n}\n\nasync function instrumentRequestStartHttpServerSpan(\n  ctx: Parameters<MiddlewareResponseHandler>[0],\n  next: Parameters<MiddlewareResponseHandler>[1],\n  options: MiddlewareOptions,\n): Promise<Response> {\n  // Make sure we don't accidentally double wrap (e.g. user added middleware and integration auto added it)\n  const locals = ctx.locals as AstroLocalsWithSentry | undefined;\n  if (locals?.__sentry_wrapped__) {\n    return next();\n  }\n  if (locals) {\n    addNonEnumerableProperty(locals, '__sentry_wrapped__', true);\n  }\n\n  const request = ctx.request;\n\n  // Note: We guard outside of this function call that the request is dynamic\n  // accessing headers on a static route would throw\n  const { method, headers } = request;\n\n  return withIsolationScope(isolationScope => {\n    return continueTrace(\n      {\n        sentryTrace: headers?.get('sentry-trace') || undefined,\n        baggage: headers?.get('baggage'),\n      },\n      async () => {\n        getCurrentScope().setSDKProcessingMetadata({\n          // We store the request on the current scope, not isolation scope,\n          // because we may have multiple requests nested inside each other\n          normalizedRequest: winterCGRequestToRequestData(request),\n        });\n\n        if (options.trackClientIp) {\n          isolationScope.setUser({ ip_address: ctx.clientAddress });\n        }\n\n        try {\n          const parametrizedRoute = getParametrizedRoute(ctx);\n\n          const source = parametrizedRoute ? 'route' : 'url';\n          // storing res in a variable instead of directly returning is necessary to\n          // invoke the catch block if next() throws\n\n          const attributes: SpanAttributes = {\n            [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.http.astro',\n            [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: source,\n            [SEMANTIC_ATTRIBUTE_HTTP_REQUEST_METHOD]: method,\n            // This is here for backwards compatibility, we used to set this here before\n            method,\n            url: stripUrlQueryAndFragment(ctx.url.href),\n            ...httpHeadersToSpanAttributes(\n              winterCGHeadersToDict(request.headers),\n              getClient()?.getOptions().sendDefaultPii ?? false,\n            ),\n          };\n\n          if (parametrizedRoute) {\n            attributes['http.route'] = parametrizedRoute;\n          }\n\n          if (ctx.url.search) {\n            attributes['http.query'] = ctx.url.search;\n          }\n\n          if (ctx.url.hash) {\n            attributes['http.fragment'] = ctx.url.hash;\n          }\n\n          isolationScope.setTransactionName(`${method} ${parametrizedRoute || ctx.url.pathname}`);\n\n          const res = await startSpan(\n            {\n              attributes,\n              name: `${method} ${parametrizedRoute || ctx.url.pathname}`,\n              op: 'http.server',\n            },\n            async span => {\n              try {\n                const originalResponse = await next();\n                if (originalResponse.status) {\n                  setHttpStatus(span, originalResponse.status);\n                }\n\n                const metaTagsStr = getMetaTagsStr({ injectTraceData: true, parametrizedRoute });\n                return injectMetaTagsInResponse(originalResponse, metaTagsStr);\n              } catch (e) {\n                sendErrorToSentry(e);\n                throw e;\n              }\n            },\n          );\n          return res;\n        } finally {\n          await flushIfServerless();\n        }\n        // TODO: flush if serverless (first extract function)\n      },\n    );\n  });\n}\n\n/**\n * This function optimistically assumes that the HTML coming in chunks will not be split\n * within the <head> tag. If this still happens, we simply won't replace anything.\n */\nfunction addMetaTagToHead(htmlChunk: string, metaTagsStr: string): string {\n  if (typeof htmlChunk !== 'string' || !metaTagsStr) {\n    return htmlChunk;\n  }\n\n  const content = `<head>${metaTagsStr}`;\n  return htmlChunk.replace('<head>', content);\n}\n\nfunction getMetaTagsStr({\n  injectTraceData,\n  parametrizedRoute,\n}: {\n  injectTraceData: boolean;\n  parametrizedRoute: string | undefined;\n}): string {\n  const parts = [];\n  if (injectTraceData) {\n    parts.push(getTraceMetaTags());\n  }\n  if (parametrizedRoute) {\n    parts.push(`<meta name=\"sentry-route-name\" content=\"${encodeURIComponent(parametrizedRoute)}\"/>`);\n  }\n  return parts.join('\\n');\n}\n\n/**\n * Interpolates the route from the URL and the passed params.\n * Best we can do to get a route name instead of a raw URL.\n *\n * exported for testing\n *\n * @param rawUrlPathname - The raw URL pathname, e.g. '/users/123/details'\n * @param params - The params object, e.g. `{ userId: '123' }`\n *\n * @returns The interpolated route, e.g. '/users/[userId]/details'\n */\nexport function interpolateRouteFromUrlAndParams(\n  rawUrlPathname: string,\n  params: APIContext['params'],\n): string | undefined {\n  const decodedUrlPathname = tryDecodeUrl(rawUrlPathname);\n  if (!decodedUrlPathname) {\n    return undefined;\n  }\n\n  // Invert params map so that the param values are the keys\n  // differentiate between rest params spanning multiple url segments\n  // and normal, single-segment params.\n  const valuesToMultiSegmentParams: Record<string, string> = {};\n  const valuesToParams: Record<string, string> = {};\n  Object.entries(params).forEach(([key, value]) => {\n    if (!value) {\n      return;\n    }\n    if (value.includes('/')) {\n      valuesToMultiSegmentParams[value] = key;\n      return;\n    }\n    valuesToParams[value] = key;\n  });\n\n  function replaceWithParamName(segment: string): string {\n    const param = valuesToParams[segment];\n    if (param) {\n      return `[${param}]`;\n    }\n    return segment;\n  }\n\n  // before we match single-segment params, we first replace multi-segment params\n  const urlWithReplacedMultiSegmentParams = Object.keys(valuesToMultiSegmentParams).reduce((acc, key) => {\n    return acc.replace(key, `[${valuesToMultiSegmentParams[key]}]`);\n  }, decodedUrlPathname);\n\n  return (\n    urlWithReplacedMultiSegmentParams\n      .split('/')\n      .map(segment => {\n        if (!segment) {\n          return '';\n        }\n\n        if (valuesToParams[segment]) {\n          return replaceWithParamName(segment);\n        }\n\n        // astro permits multiple params in a single path segment, e.g. /[foo]-[bar]/\n        const segmentParts = segment.split('-');\n        if (segmentParts.length > 1) {\n          return segmentParts.map(part => replaceWithParamName(part)).join('-');\n        }\n\n        return segment;\n      })\n      .join('/')\n      // Remove trailing slash (only if it's not the only segment)\n      .replace(/^(.+?)\\/$/, '$1')\n  );\n}\n\nfunction tryDecodeUrl(url: string): string | undefined {\n  try {\n    return decodeURI(url);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Checks if the incoming request is a request for a dynamic (server-side rendered) page.\n * We can check this by looking at the middleware's `clientAddress` context property because accessing\n * this prop in a static route will throw an error which we can conveniently catch.\n */\nfunction checkIsDynamicPageRequest(context: Parameters<MiddlewareResponseHandler>[0]): boolean {\n  try {\n    return context.clientAddress != null;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Join Astro route segments into a case-sensitive single path string.\n *\n * Astro lowercases the parametrized route. Joining segments manually is recommended to get the correct casing of the routes.\n * Recommendation in comment: https://github.com/withastro/astro/issues/13885#issuecomment-2934203029\n * Function Reference: https://github.com/joanrieu/astro-typed-links/blob/b3dc12c6fe8d672a2bc2ae2ccc57c8071bbd09fa/package/src/integration.ts#L16\n */\nfunction joinRouteSegments(segments: RoutePart[][]): string {\n  const parthArray = segments.map(segment =>\n    segment.map(routePart => (routePart.dynamic ? `[${routePart.content}]` : routePart.content)).join(''),\n  );\n\n  return `/${parthArray.join('/')}`;\n}\n\nfunction getParametrizedRoute(\n  ctx: Parameters<MiddlewareResponseHandler>[0] & { routePattern?: string },\n): string | undefined {\n  try {\n    // `routePattern` is available after Astro 5\n    const contextWithRoutePattern = ctx;\n    const rawRoutePattern = contextWithRoutePattern.routePattern;\n\n    // @ts-expect-error Implicit any on Symbol.for (This is available in Astro 5)\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const routesFromManifest = ctx?.[Symbol.for('context.routes')]?.manifest?.routes;\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n    const matchedRouteSegmentsFromManifest = routesFromManifest?.find(\n      (route: { routeData?: { route?: string } }) => route?.routeData?.route === rawRoutePattern,\n    )?.routeData?.segments;\n\n    return (\n      // Astro v5 - Joining the segments to get the correct casing of the parametrized route\n      (matchedRouteSegmentsFromManifest && joinRouteSegments(matchedRouteSegmentsFromManifest)) ||\n      // Fallback (Astro v4 and earlier)\n      interpolateRouteFromUrlAndParams(ctx.url.pathname, ctx.params)\n    );\n  } catch {\n    return undefined;\n  }\n}\n\nfunction injectMetaTagsInResponse(originalResponse: Response, metaTagsStr: string): Response {\n  try {\n    const contentType = originalResponse.headers.get('content-type');\n\n    const isPageloadRequest = contentType?.startsWith('text/html');\n    if (!isPageloadRequest) {\n      return originalResponse;\n    }\n\n    // Type case necessary b/c the body's ReadableStream type doesn't include\n    // the async iterator that is actually available in Node\n    // We later on use the async iterator to read the body chunks\n    // see https://github.com/microsoft/TypeScript/issues/39051\n    const originalBody = originalResponse.body as NodeJS.ReadableStream | null;\n    if (!originalBody) {\n      return originalResponse;\n    }\n\n    const decoder = new TextDecoder();\n\n    const newResponseStream = new ReadableStream({\n      start: async controller => {\n        // Assign to a new variable to avoid TS losing the narrower type checked above.\n        const body = originalBody;\n\n        async function* bodyReporter(): AsyncGenerator<string | Buffer> {\n          try {\n            for await (const chunk of body) {\n              yield chunk;\n            }\n          } catch (e) {\n            // Report stream errors coming from user code or Astro rendering.\n            sendErrorToSentry(e);\n            throw e;\n          }\n        }\n\n        try {\n          for await (const chunk of bodyReporter()) {\n            const html = typeof chunk === 'string' ? chunk : decoder.decode(chunk, { stream: true });\n            const modifiedHtml = addMetaTagToHead(html, metaTagsStr);\n            controller.enqueue(new TextEncoder().encode(modifiedHtml));\n          }\n        } catch (e) {\n          controller.error(e);\n        } finally {\n          controller.close();\n        }\n      },\n    });\n\n    return new Response(newResponseStream, originalResponse);\n  } catch (e) {\n    sendErrorToSentry(e);\n    throw e;\n  }\n}\n"],"names":[],"mappings":"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"}